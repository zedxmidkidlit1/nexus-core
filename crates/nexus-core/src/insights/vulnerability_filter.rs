//! Smart CVE filtering based on device context
//!
//! Filters vulnerabilities based on device type and open ports to eliminate false positives

use crate::database::queries;
use crate::models::VulnerabilityInfo;
use anyhow::Result;
use rusqlite::Connection;

/// Filter vulnerabilities based on device context (device type + open ports)
pub fn filter_vulnerabilities_by_context(
    conn: &Connection,
    vendor: &str,
    device_type: &str,
    open_ports: &[u16],
) -> Result<Vec<VulnerabilityInfo>> {
    let mut vulnerabilities = Vec::new();

    // Normalize device type for matching
    let device_type_lower = device_type.to_lowercase();

    // Step 1: Get vendor-specific CVEs (always include)
    let vendor_cves = queries::lookup_vulnerabilities(conn, vendor)?;
    vulnerabilities.extend(vendor_cves.into_iter().filter(|cve| {
        // Exclude wildcard CVEs from vendor lookup
        !cve.cve_id.starts_with("CVE-TELNET") && 
        !cve.cve_id.starts_with("CVE-FTP") && 
        !cve.cve_id.starts_with("CVE-HTTP") &&
        cve.cve_id != "CVE-2017-0144" &&  // EternalBlue
        cve.cve_id != "CVE-2019-0708" // BlueKeep
    }));

    // Step 2: Add Windows-specific CVEs ONLY if device is Windows AND ports are open
    if is_windows_device(&device_type_lower) {
        // EternalBlue - ONLY if SMB port is open
        if open_ports.contains(&445)
            && let Ok(mut smb_cves) = get_wildcard_cve(conn, "CVE-2017-0144")
        {
            vulnerabilities.append(&mut smb_cves);
        }

        // BlueKeep - ONLY if RDP port is open
        if open_ports.contains(&3389)
            && let Ok(mut rdp_cves) = get_wildcard_cve(conn, "CVE-2019-0708")
        {
            vulnerabilities.append(&mut rdp_cves);
        }
    }

    // Step 3: Add universal port warnings for ALL device types
    add_universal_port_warnings(conn, open_ports, &mut vulnerabilities)?;

    Ok(vulnerabilities)
}

/// Check if device is Windows-based
fn is_windows_device(device_type: &str) -> bool {
    let normalized = device_type.to_lowercase();
    normalized.contains("windows")
        || normalized.contains("microsoft")
        || normalized.contains("win10")
        || normalized.contains("win11")
}

/// Get a specific wildcard CVE by ID
fn get_wildcard_cve(conn: &Connection, cve_id: &str) -> Result<Vec<VulnerabilityInfo>> {
    use rusqlite::params;

    let mut stmt = conn.prepare(
        r#"
        SELECT cve_id, description, severity, cvss_score
        FROM cve_cache
        WHERE cve_id = ?1 AND vendor = '*'
        "#,
    )?;

    let cves = stmt
        .query_map(params![cve_id], |row| {
            Ok(VulnerabilityInfo {
                cve_id: row.get(0)?,
                description: row.get(1)?,
                severity: row.get(2)?,
                cvss_score: row.get(3)?,
            })
        })?
        .collect::<rusqlite::Result<Vec<_>>>()?;

    Ok(cves)
}

/// Add universal port warnings (Telnet, FTP, HTTP) for all device types
fn add_universal_port_warnings(
    conn: &Connection,
    open_ports: &[u16],
    vulnerabilities: &mut Vec<VulnerabilityInfo>,
) -> Result<()> {
    // Port-to-CVE mapping for universal warnings
    let port_cve_map = [
        (23, "CVE-TELNET-001"), // Telnet
        (21, "CVE-FTP-001"),    // FTP
        (80, "CVE-HTTP-001"),   // HTTP
    ];

    for (port, cve_id) in port_cve_map {
        if open_ports.contains(&port)
            && let Ok(mut cves) = get_wildcard_cve(conn, cve_id)
        {
            vulnerabilities.append(&mut cves);
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_windows_device() {
        assert!(is_windows_device("windows"));
        assert!(is_windows_device("Windows PC"));
        assert!(is_windows_device("Windows Server 2019"));
        assert!(!is_windows_device("linux server"));
        assert!(!is_windows_device("pc"));
        assert!(!is_windows_device("android"));
        assert!(!is_windows_device("router"));
    }

    #[test]
    fn test_android_no_windows_cves() {
        // Test would verify Android devices don't get Windows CVEs
        // Requires database connection - integration test
    }
}
